/*
 Written by Susi Lehtola, 2016
 Copyright (c) 2016, Susi Lehtola

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.
*/

/* This code is autogenerated by gentensor.py. Don't edit it by hand. */

#include "tensor.hh"
#include "sort.hh"
#include <cmath>
#include <algorithm>
#include <stdexcept>

bool operator<(const Tensor1_entry_t & lh, const Tensor1_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  return false;
}
bool operator==(const Tensor1_entry_t & lh, const Tensor1_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.v0 != rh.v0) return false;
  return true;
}
Tensor1_entry_t make_entry1(orbind_t o0, orbind_t v0) {
  Tensor1_entry_t etr;

  etr.el=1.0;
  etr.o0=o0;
  etr.v0=v0;

  return etr;
}
void unroll_entry1(const Tensor1_entry_t & etr, orbind_t & o0, orbind_t & v0, double & val) {
  o0=etr.o0;
  v0=etr.v0;
  val=etr.el;
}
void unroll_entry1(const Tensor1_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(2);
  idx[0]=etr.o0;
  idx[1]=etr.v0;
  val = etr.el;
}
Tensor1::Tensor1() {
}
Tensor1::Tensor1(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 1) continue;
    orbind_t o0;
    orbind_t v0;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    Tensor1_entry_t etr(make_entry1(o0, v0));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-1 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i -> %i\n",o0,v0);
#endif
  }
}
Tensor1::~Tensor1() {
}
void Tensor1::add(const Tensor1_entry_t & val) {
  std::vector<Tensor1_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor1::size() const {
 return list.size();
}
double Tensor1::operator()(orbind_t o0, orbind_t v0) const {
  Tensor1_entry_t key(make_entry1(o0, v0));
  std::vector<Tensor1_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor1_entry_t Tensor1::get(size_t idx) const {
  return list[idx];
}
void Tensor1::set(size_t idx, Tensor1_entry_t val) {
  list[idx]=val;
}
void Tensor1::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor1::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor1::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i) -> (%2i) % e\n",list[i].o0,list[i].v0,list[i].el);
  }
}
bool operator<(const Tensor2_entry_t & lh, const Tensor2_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  return false;
}
bool operator==(const Tensor2_entry_t & lh, const Tensor2_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  return true;
}
Tensor2_entry_t make_entry2(orbind_t o0, orbind_t o1, orbind_t v0, orbind_t v1) {
  Tensor2_entry_t etr;

  std::vector<orbind_t> oidx(2);
  oidx[0]=o0;
  oidx[1]=o1;

  std::vector<orbind_t> vidx(2);
  vidx[0]=v0;
  vidx[1]=v1;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.v0=svidx[0];
  etr.v1=svidx[1];

  return etr;
}
void unroll_entry2(const Tensor2_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & v0, orbind_t & v1, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  v0=etr.v0;
  v1=etr.v1;
  val=etr.el;
}
void unroll_entry2(const Tensor2_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(4);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.v0;
  idx[3]=etr.v1;
  val = etr.el;
}
Tensor2::Tensor2() {
}
Tensor2::Tensor2(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 2) continue;
    orbind_t o0, o1;
    orbind_t v0, v1;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    Tensor2_entry_t etr(make_entry2(o0, o1, v0, v1));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-2 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i -> %i %i\n",o0,o1,v0,v1);
#endif
  }
}
Tensor2::~Tensor2() {
}
void Tensor2::add(const Tensor2_entry_t & val) {
  std::vector<Tensor2_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor2::size() const {
 return list.size();
}
double Tensor2::operator()(orbind_t o0, orbind_t o1, orbind_t v0, orbind_t v1) const {
  Tensor2_entry_t key(make_entry2(o0, o1, v0, v1));
  std::vector<Tensor2_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor2_entry_t Tensor2::get(size_t idx) const {
  return list[idx];
}
void Tensor2::set(size_t idx, Tensor2_entry_t val) {
  list[idx]=val;
}
void Tensor2::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor2::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor2::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i) -> (%2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].v0,list[i].v1,list[i].el);
  }
}
bool operator<(const Tensor3_entry_t & lh, const Tensor3_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  return false;
}
bool operator==(const Tensor3_entry_t & lh, const Tensor3_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  return true;
}
Tensor3_entry_t make_entry3(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t v0, orbind_t v1, orbind_t v2) {
  Tensor3_entry_t etr;

  std::vector<orbind_t> oidx(3);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;

  std::vector<orbind_t> vidx(3);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];

  return etr;
}
void unroll_entry3(const Tensor3_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & v0, orbind_t & v1, orbind_t & v2, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  val=etr.el;
}
void unroll_entry3(const Tensor3_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(6);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.v0;
  idx[4]=etr.v1;
  idx[5]=etr.v2;
  val = etr.el;
}
Tensor3::Tensor3() {
}
Tensor3::Tensor3(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 3) continue;
    orbind_t o0, o1, o2;
    orbind_t v0, v1, v2;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    Tensor3_entry_t etr(make_entry3(o0, o1, o2, v0, v1, v2));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-3 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i -> %i %i %i\n",o0,o1,o2,v0,v1,v2);
#endif
  }
}
Tensor3::~Tensor3() {
}
void Tensor3::add(const Tensor3_entry_t & val) {
  std::vector<Tensor3_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor3::size() const {
 return list.size();
}
double Tensor3::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t v0, orbind_t v1, orbind_t v2) const {
  Tensor3_entry_t key(make_entry3(o0, o1, o2, v0, v1, v2));
  std::vector<Tensor3_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor3_entry_t Tensor3::get(size_t idx) const {
  return list[idx];
}
void Tensor3::set(size_t idx, Tensor3_entry_t val) {
  list[idx]=val;
}
void Tensor3::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor3::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor3::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i) -> (%2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].v0,list[i].v1,list[i].v2,list[i].el);
  }
}
bool operator<(const Tensor4_entry_t & lh, const Tensor4_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  return false;
}
bool operator==(const Tensor4_entry_t & lh, const Tensor4_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  return true;
}
Tensor4_entry_t make_entry4(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3) {
  Tensor4_entry_t etr;

  std::vector<orbind_t> oidx(4);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;

  std::vector<orbind_t> vidx(4);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];

  return etr;
}
void unroll_entry4(const Tensor4_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  val=etr.el;
}
void unroll_entry4(const Tensor4_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(8);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.v0;
  idx[5]=etr.v1;
  idx[6]=etr.v2;
  idx[7]=etr.v3;
  val = etr.el;
}
Tensor4::Tensor4() {
}
Tensor4::Tensor4(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 4) continue;
    orbind_t o0, o1, o2, o3;
    orbind_t v0, v1, v2, v3;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    Tensor4_entry_t etr(make_entry4(o0, o1, o2, o3, v0, v1, v2, v3));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-4 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i -> %i %i %i %i\n",o0,o1,o2,o3,v0,v1,v2,v3);
#endif
  }
}
Tensor4::~Tensor4() {
}
void Tensor4::add(const Tensor4_entry_t & val) {
  std::vector<Tensor4_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor4::size() const {
 return list.size();
}
double Tensor4::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3) const {
  Tensor4_entry_t key(make_entry4(o0, o1, o2, o3, v0, v1, v2, v3));
  std::vector<Tensor4_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor4_entry_t Tensor4::get(size_t idx) const {
  return list[idx];
}
void Tensor4::set(size_t idx, Tensor4_entry_t val) {
  list[idx]=val;
}
void Tensor4::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor4::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor4::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].el);
  }
}
bool operator<(const Tensor5_entry_t & lh, const Tensor5_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  return false;
}
bool operator==(const Tensor5_entry_t & lh, const Tensor5_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  return true;
}
Tensor5_entry_t make_entry5(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4) {
  Tensor5_entry_t etr;

  std::vector<orbind_t> oidx(5);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;

  std::vector<orbind_t> vidx(5);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];

  return etr;
}
void unroll_entry5(const Tensor5_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  val=etr.el;
}
void unroll_entry5(const Tensor5_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(10);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.v0;
  idx[6]=etr.v1;
  idx[7]=etr.v2;
  idx[8]=etr.v3;
  idx[9]=etr.v4;
  val = etr.el;
}
Tensor5::Tensor5() {
}
Tensor5::Tensor5(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 5) continue;
    orbind_t o0, o1, o2, o3, o4;
    orbind_t v0, v1, v2, v3, v4;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    Tensor5_entry_t etr(make_entry5(o0, o1, o2, o3, o4, v0, v1, v2, v3, v4));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-5 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i -> %i %i %i %i %i\n",o0,o1,o2,o3,o4,v0,v1,v2,v3,v4);
#endif
  }
}
Tensor5::~Tensor5() {
}
void Tensor5::add(const Tensor5_entry_t & val) {
  std::vector<Tensor5_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor5::size() const {
 return list.size();
}
double Tensor5::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4) const {
  Tensor5_entry_t key(make_entry5(o0, o1, o2, o3, o4, v0, v1, v2, v3, v4));
  std::vector<Tensor5_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor5_entry_t Tensor5::get(size_t idx) const {
  return list[idx];
}
void Tensor5::set(size_t idx, Tensor5_entry_t val) {
  list[idx]=val;
}
void Tensor5::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor5::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor5::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].el);
  }
}
bool operator<(const Tensor6_entry_t & lh, const Tensor6_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  return false;
}
bool operator==(const Tensor6_entry_t & lh, const Tensor6_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  return true;
}
Tensor6_entry_t make_entry6(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5) {
  Tensor6_entry_t etr;

  std::vector<orbind_t> oidx(6);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;

  std::vector<orbind_t> vidx(6);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];

  return etr;
}
void unroll_entry6(const Tensor6_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  val=etr.el;
}
void unroll_entry6(const Tensor6_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(12);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.v0;
  idx[7]=etr.v1;
  idx[8]=etr.v2;
  idx[9]=etr.v3;
  idx[10]=etr.v4;
  idx[11]=etr.v5;
  val = etr.el;
}
Tensor6::Tensor6() {
}
Tensor6::Tensor6(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 6) continue;
    orbind_t o0, o1, o2, o3, o4, o5;
    orbind_t v0, v1, v2, v3, v4, v5;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    Tensor6_entry_t etr(make_entry6(o0, o1, o2, o3, o4, o5, v0, v1, v2, v3, v4, v5));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-6 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i -> %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,v0,v1,v2,v3,v4,v5);
#endif
  }
}
Tensor6::~Tensor6() {
}
void Tensor6::add(const Tensor6_entry_t & val) {
  std::vector<Tensor6_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor6::size() const {
 return list.size();
}
double Tensor6::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5) const {
  Tensor6_entry_t key(make_entry6(o0, o1, o2, o3, o4, o5, v0, v1, v2, v3, v4, v5));
  std::vector<Tensor6_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor6_entry_t Tensor6::get(size_t idx) const {
  return list[idx];
}
void Tensor6::set(size_t idx, Tensor6_entry_t val) {
  list[idx]=val;
}
void Tensor6::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor6::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor6::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].el);
  }
}
bool operator<(const Tensor7_entry_t & lh, const Tensor7_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  return false;
}
bool operator==(const Tensor7_entry_t & lh, const Tensor7_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  return true;
}
Tensor7_entry_t make_entry7(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6) {
  Tensor7_entry_t etr;

  std::vector<orbind_t> oidx(7);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;

  std::vector<orbind_t> vidx(7);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];

  return etr;
}
void unroll_entry7(const Tensor7_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  val=etr.el;
}
void unroll_entry7(const Tensor7_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(14);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.v0;
  idx[8]=etr.v1;
  idx[9]=etr.v2;
  idx[10]=etr.v3;
  idx[11]=etr.v4;
  idx[12]=etr.v5;
  idx[13]=etr.v6;
  val = etr.el;
}
Tensor7::Tensor7() {
}
Tensor7::Tensor7(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 7) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6;
    orbind_t v0, v1, v2, v3, v4, v5, v6;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    Tensor7_entry_t etr(make_entry7(o0, o1, o2, o3, o4, o5, o6, v0, v1, v2, v3, v4, v5, v6));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-7 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,v0,v1,v2,v3,v4,v5,v6);
#endif
  }
}
Tensor7::~Tensor7() {
}
void Tensor7::add(const Tensor7_entry_t & val) {
  std::vector<Tensor7_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor7::size() const {
 return list.size();
}
double Tensor7::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6) const {
  Tensor7_entry_t key(make_entry7(o0, o1, o2, o3, o4, o5, o6, v0, v1, v2, v3, v4, v5, v6));
  std::vector<Tensor7_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor7_entry_t Tensor7::get(size_t idx) const {
  return list[idx];
}
void Tensor7::set(size_t idx, Tensor7_entry_t val) {
  list[idx]=val;
}
void Tensor7::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor7::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor7::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].el);
  }
}
bool operator<(const Tensor8_entry_t & lh, const Tensor8_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  return false;
}
bool operator==(const Tensor8_entry_t & lh, const Tensor8_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  return true;
}
Tensor8_entry_t make_entry8(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7) {
  Tensor8_entry_t etr;

  std::vector<orbind_t> oidx(8);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;

  std::vector<orbind_t> vidx(8);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];

  return etr;
}
void unroll_entry8(const Tensor8_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  val=etr.el;
}
void unroll_entry8(const Tensor8_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(16);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.v0;
  idx[9]=etr.v1;
  idx[10]=etr.v2;
  idx[11]=etr.v3;
  idx[12]=etr.v4;
  idx[13]=etr.v5;
  idx[14]=etr.v6;
  idx[15]=etr.v7;
  val = etr.el;
}
Tensor8::Tensor8() {
}
Tensor8::Tensor8(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 8) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    Tensor8_entry_t etr(make_entry8(o0, o1, o2, o3, o4, o5, o6, o7, v0, v1, v2, v3, v4, v5, v6, v7));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-8 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,v0,v1,v2,v3,v4,v5,v6,v7);
#endif
  }
}
Tensor8::~Tensor8() {
}
void Tensor8::add(const Tensor8_entry_t & val) {
  std::vector<Tensor8_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor8::size() const {
 return list.size();
}
double Tensor8::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7) const {
  Tensor8_entry_t key(make_entry8(o0, o1, o2, o3, o4, o5, o6, o7, v0, v1, v2, v3, v4, v5, v6, v7));
  std::vector<Tensor8_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor8_entry_t Tensor8::get(size_t idx) const {
  return list[idx];
}
void Tensor8::set(size_t idx, Tensor8_entry_t val) {
  list[idx]=val;
}
void Tensor8::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor8::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor8::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].el);
  }
}
bool operator<(const Tensor9_entry_t & lh, const Tensor9_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  return false;
}
bool operator==(const Tensor9_entry_t & lh, const Tensor9_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  return true;
}
Tensor9_entry_t make_entry9(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8) {
  Tensor9_entry_t etr;

  std::vector<orbind_t> oidx(9);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;

  std::vector<orbind_t> vidx(9);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];

  return etr;
}
void unroll_entry9(const Tensor9_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  val=etr.el;
}
void unroll_entry9(const Tensor9_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(18);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.v0;
  idx[10]=etr.v1;
  idx[11]=etr.v2;
  idx[12]=etr.v3;
  idx[13]=etr.v4;
  idx[14]=etr.v5;
  idx[15]=etr.v6;
  idx[16]=etr.v7;
  idx[17]=etr.v8;
  val = etr.el;
}
Tensor9::Tensor9() {
}
Tensor9::Tensor9(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 9) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    Tensor9_entry_t etr(make_entry9(o0, o1, o2, o3, o4, o5, o6, o7, o8, v0, v1, v2, v3, v4, v5, v6, v7, v8));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-9 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,v0,v1,v2,v3,v4,v5,v6,v7,v8);
#endif
  }
}
Tensor9::~Tensor9() {
}
void Tensor9::add(const Tensor9_entry_t & val) {
  std::vector<Tensor9_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor9::size() const {
 return list.size();
}
double Tensor9::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8) const {
  Tensor9_entry_t key(make_entry9(o0, o1, o2, o3, o4, o5, o6, o7, o8, v0, v1, v2, v3, v4, v5, v6, v7, v8));
  std::vector<Tensor9_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor9_entry_t Tensor9::get(size_t idx) const {
  return list[idx];
}
void Tensor9::set(size_t idx, Tensor9_entry_t val) {
  list[idx]=val;
}
void Tensor9::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor9::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor9::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].el);
  }
}
bool operator<(const Tensor10_entry_t & lh, const Tensor10_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  return false;
}
bool operator==(const Tensor10_entry_t & lh, const Tensor10_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  return true;
}
Tensor10_entry_t make_entry10(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9) {
  Tensor10_entry_t etr;

  std::vector<orbind_t> oidx(10);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;

  std::vector<orbind_t> vidx(10);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];

  return etr;
}
void unroll_entry10(const Tensor10_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  val=etr.el;
}
void unroll_entry10(const Tensor10_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(20);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.v0;
  idx[11]=etr.v1;
  idx[12]=etr.v2;
  idx[13]=etr.v3;
  idx[14]=etr.v4;
  idx[15]=etr.v5;
  idx[16]=etr.v6;
  idx[17]=etr.v7;
  idx[18]=etr.v8;
  idx[19]=etr.v9;
  val = etr.el;
}
Tensor10::Tensor10() {
}
Tensor10::Tensor10(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 10) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    Tensor10_entry_t etr(make_entry10(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-10 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9);
#endif
  }
}
Tensor10::~Tensor10() {
}
void Tensor10::add(const Tensor10_entry_t & val) {
  std::vector<Tensor10_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor10::size() const {
 return list.size();
}
double Tensor10::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9) const {
  Tensor10_entry_t key(make_entry10(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9));
  std::vector<Tensor10_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor10_entry_t Tensor10::get(size_t idx) const {
  return list[idx];
}
void Tensor10::set(size_t idx, Tensor10_entry_t val) {
  list[idx]=val;
}
void Tensor10::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor10::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor10::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].el);
  }
}
bool operator<(const Tensor11_entry_t & lh, const Tensor11_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.o10 < rh.o10) return true;
  if(lh.o10 > rh.o10) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  if(lh.v10 < rh.v10) return true;
  if(lh.v10 > rh.v10) return false;
  return false;
}
bool operator==(const Tensor11_entry_t & lh, const Tensor11_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.o10 != rh.o10) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  if(lh.v10 != rh.v10) return false;
  return true;
}
Tensor11_entry_t make_entry11(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10) {
  Tensor11_entry_t etr;

  std::vector<orbind_t> oidx(11);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;
  oidx[10]=o10;

  std::vector<orbind_t> vidx(11);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;
  vidx[10]=v10;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.o10=soidx[10];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];
  etr.v10=svidx[10];

  return etr;
}
void unroll_entry11(const Tensor11_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & o10, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, orbind_t & v10, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  o10=etr.o10;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  v10=etr.v10;
  val=etr.el;
}
void unroll_entry11(const Tensor11_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(22);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.o10;
  idx[11]=etr.v0;
  idx[12]=etr.v1;
  idx[13]=etr.v2;
  idx[14]=etr.v3;
  idx[15]=etr.v4;
  idx[16]=etr.v5;
  idx[17]=etr.v6;
  idx[18]=etr.v7;
  idx[19]=etr.v8;
  idx[20]=etr.v9;
  idx[21]=etr.v10;
  val = etr.el;
}
Tensor11::Tensor11() {
}
Tensor11::Tensor11(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 11) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(o10=o9+1;o10<(orbind_t) list[idet].occ.size();o10++)
      if(!list[idet].occ[o10]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    for(v10=v9+1;v10<(orbind_t) list[idet].virt.size();v10++)
      if(list[idet].virt[v10]) break;
    Tensor11_entry_t etr(make_entry11(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-11 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,o10,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10);
#endif
  }
}
Tensor11::~Tensor11() {
}
void Tensor11::add(const Tensor11_entry_t & val) {
  std::vector<Tensor11_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor11::size() const {
 return list.size();
}
double Tensor11::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10) const {
  Tensor11_entry_t key(make_entry11(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10));
  std::vector<Tensor11_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor11_entry_t Tensor11::get(size_t idx) const {
  return list[idx];
}
void Tensor11::set(size_t idx, Tensor11_entry_t val) {
  list[idx]=val;
}
void Tensor11::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor11::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor11::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].o10,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].v10,list[i].el);
  }
}
bool operator<(const Tensor12_entry_t & lh, const Tensor12_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.o10 < rh.o10) return true;
  if(lh.o10 > rh.o10) return false;
  if(lh.o11 < rh.o11) return true;
  if(lh.o11 > rh.o11) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  if(lh.v10 < rh.v10) return true;
  if(lh.v10 > rh.v10) return false;
  if(lh.v11 < rh.v11) return true;
  if(lh.v11 > rh.v11) return false;
  return false;
}
bool operator==(const Tensor12_entry_t & lh, const Tensor12_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.o10 != rh.o10) return false;
  if(lh.o11 != rh.o11) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  if(lh.v10 != rh.v10) return false;
  if(lh.v11 != rh.v11) return false;
  return true;
}
Tensor12_entry_t make_entry12(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11) {
  Tensor12_entry_t etr;

  std::vector<orbind_t> oidx(12);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;
  oidx[10]=o10;
  oidx[11]=o11;

  std::vector<orbind_t> vidx(12);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;
  vidx[10]=v10;
  vidx[11]=v11;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.o10=soidx[10];
  etr.o11=soidx[11];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];
  etr.v10=svidx[10];
  etr.v11=svidx[11];

  return etr;
}
void unroll_entry12(const Tensor12_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & o10, orbind_t & o11, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, orbind_t & v10, orbind_t & v11, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  o10=etr.o10;
  o11=etr.o11;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  v10=etr.v10;
  v11=etr.v11;
  val=etr.el;
}
void unroll_entry12(const Tensor12_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(24);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.o10;
  idx[11]=etr.o11;
  idx[12]=etr.v0;
  idx[13]=etr.v1;
  idx[14]=etr.v2;
  idx[15]=etr.v3;
  idx[16]=etr.v4;
  idx[17]=etr.v5;
  idx[18]=etr.v6;
  idx[19]=etr.v7;
  idx[20]=etr.v8;
  idx[21]=etr.v9;
  idx[22]=etr.v10;
  idx[23]=etr.v11;
  val = etr.el;
}
Tensor12::Tensor12() {
}
Tensor12::Tensor12(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 12) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(o10=o9+1;o10<(orbind_t) list[idet].occ.size();o10++)
      if(!list[idet].occ[o10]) break;
    for(o11=o10+1;o11<(orbind_t) list[idet].occ.size();o11++)
      if(!list[idet].occ[o11]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    for(v10=v9+1;v10<(orbind_t) list[idet].virt.size();v10++)
      if(list[idet].virt[v10]) break;
    for(v11=v10+1;v11<(orbind_t) list[idet].virt.size();v11++)
      if(list[idet].virt[v11]) break;
    Tensor12_entry_t etr(make_entry12(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-12 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,o10,o11,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11);
#endif
  }
}
Tensor12::~Tensor12() {
}
void Tensor12::add(const Tensor12_entry_t & val) {
  std::vector<Tensor12_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor12::size() const {
 return list.size();
}
double Tensor12::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11) const {
  Tensor12_entry_t key(make_entry12(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11));
  std::vector<Tensor12_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor12_entry_t Tensor12::get(size_t idx) const {
  return list[idx];
}
void Tensor12::set(size_t idx, Tensor12_entry_t val) {
  list[idx]=val;
}
void Tensor12::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor12::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor12::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].o10,list[i].o11,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].v10,list[i].v11,list[i].el);
  }
}
bool operator<(const Tensor13_entry_t & lh, const Tensor13_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.o10 < rh.o10) return true;
  if(lh.o10 > rh.o10) return false;
  if(lh.o11 < rh.o11) return true;
  if(lh.o11 > rh.o11) return false;
  if(lh.o12 < rh.o12) return true;
  if(lh.o12 > rh.o12) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  if(lh.v10 < rh.v10) return true;
  if(lh.v10 > rh.v10) return false;
  if(lh.v11 < rh.v11) return true;
  if(lh.v11 > rh.v11) return false;
  if(lh.v12 < rh.v12) return true;
  if(lh.v12 > rh.v12) return false;
  return false;
}
bool operator==(const Tensor13_entry_t & lh, const Tensor13_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.o10 != rh.o10) return false;
  if(lh.o11 != rh.o11) return false;
  if(lh.o12 != rh.o12) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  if(lh.v10 != rh.v10) return false;
  if(lh.v11 != rh.v11) return false;
  if(lh.v12 != rh.v12) return false;
  return true;
}
Tensor13_entry_t make_entry13(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12) {
  Tensor13_entry_t etr;

  std::vector<orbind_t> oidx(13);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;
  oidx[10]=o10;
  oidx[11]=o11;
  oidx[12]=o12;

  std::vector<orbind_t> vidx(13);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;
  vidx[10]=v10;
  vidx[11]=v11;
  vidx[12]=v12;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.o10=soidx[10];
  etr.o11=soidx[11];
  etr.o12=soidx[12];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];
  etr.v10=svidx[10];
  etr.v11=svidx[11];
  etr.v12=svidx[12];

  return etr;
}
void unroll_entry13(const Tensor13_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & o10, orbind_t & o11, orbind_t & o12, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, orbind_t & v10, orbind_t & v11, orbind_t & v12, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  o10=etr.o10;
  o11=etr.o11;
  o12=etr.o12;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  v10=etr.v10;
  v11=etr.v11;
  v12=etr.v12;
  val=etr.el;
}
void unroll_entry13(const Tensor13_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(26);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.o10;
  idx[11]=etr.o11;
  idx[12]=etr.o12;
  idx[13]=etr.v0;
  idx[14]=etr.v1;
  idx[15]=etr.v2;
  idx[16]=etr.v3;
  idx[17]=etr.v4;
  idx[18]=etr.v5;
  idx[19]=etr.v6;
  idx[20]=etr.v7;
  idx[21]=etr.v8;
  idx[22]=etr.v9;
  idx[23]=etr.v10;
  idx[24]=etr.v11;
  idx[25]=etr.v12;
  val = etr.el;
}
Tensor13::Tensor13() {
}
Tensor13::Tensor13(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 13) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(o10=o9+1;o10<(orbind_t) list[idet].occ.size();o10++)
      if(!list[idet].occ[o10]) break;
    for(o11=o10+1;o11<(orbind_t) list[idet].occ.size();o11++)
      if(!list[idet].occ[o11]) break;
    for(o12=o11+1;o12<(orbind_t) list[idet].occ.size();o12++)
      if(!list[idet].occ[o12]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    for(v10=v9+1;v10<(orbind_t) list[idet].virt.size();v10++)
      if(list[idet].virt[v10]) break;
    for(v11=v10+1;v11<(orbind_t) list[idet].virt.size();v11++)
      if(list[idet].virt[v11]) break;
    for(v12=v11+1;v12<(orbind_t) list[idet].virt.size();v12++)
      if(list[idet].virt[v12]) break;
    Tensor13_entry_t etr(make_entry13(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-13 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,o10,o11,o12,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12);
#endif
  }
}
Tensor13::~Tensor13() {
}
void Tensor13::add(const Tensor13_entry_t & val) {
  std::vector<Tensor13_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor13::size() const {
 return list.size();
}
double Tensor13::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12) const {
  Tensor13_entry_t key(make_entry13(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12));
  std::vector<Tensor13_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor13_entry_t Tensor13::get(size_t idx) const {
  return list[idx];
}
void Tensor13::set(size_t idx, Tensor13_entry_t val) {
  list[idx]=val;
}
void Tensor13::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor13::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor13::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].o10,list[i].o11,list[i].o12,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].v10,list[i].v11,list[i].v12,list[i].el);
  }
}
bool operator<(const Tensor14_entry_t & lh, const Tensor14_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.o10 < rh.o10) return true;
  if(lh.o10 > rh.o10) return false;
  if(lh.o11 < rh.o11) return true;
  if(lh.o11 > rh.o11) return false;
  if(lh.o12 < rh.o12) return true;
  if(lh.o12 > rh.o12) return false;
  if(lh.o13 < rh.o13) return true;
  if(lh.o13 > rh.o13) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  if(lh.v10 < rh.v10) return true;
  if(lh.v10 > rh.v10) return false;
  if(lh.v11 < rh.v11) return true;
  if(lh.v11 > rh.v11) return false;
  if(lh.v12 < rh.v12) return true;
  if(lh.v12 > rh.v12) return false;
  if(lh.v13 < rh.v13) return true;
  if(lh.v13 > rh.v13) return false;
  return false;
}
bool operator==(const Tensor14_entry_t & lh, const Tensor14_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.o10 != rh.o10) return false;
  if(lh.o11 != rh.o11) return false;
  if(lh.o12 != rh.o12) return false;
  if(lh.o13 != rh.o13) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  if(lh.v10 != rh.v10) return false;
  if(lh.v11 != rh.v11) return false;
  if(lh.v12 != rh.v12) return false;
  if(lh.v13 != rh.v13) return false;
  return true;
}
Tensor14_entry_t make_entry14(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t o13, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12, orbind_t v13) {
  Tensor14_entry_t etr;

  std::vector<orbind_t> oidx(14);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;
  oidx[10]=o10;
  oidx[11]=o11;
  oidx[12]=o12;
  oidx[13]=o13;

  std::vector<orbind_t> vidx(14);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;
  vidx[10]=v10;
  vidx[11]=v11;
  vidx[12]=v12;
  vidx[13]=v13;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.o10=soidx[10];
  etr.o11=soidx[11];
  etr.o12=soidx[12];
  etr.o13=soidx[13];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];
  etr.v10=svidx[10];
  etr.v11=svidx[11];
  etr.v12=svidx[12];
  etr.v13=svidx[13];

  return etr;
}
void unroll_entry14(const Tensor14_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & o10, orbind_t & o11, orbind_t & o12, orbind_t & o13, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, orbind_t & v10, orbind_t & v11, orbind_t & v12, orbind_t & v13, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  o10=etr.o10;
  o11=etr.o11;
  o12=etr.o12;
  o13=etr.o13;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  v10=etr.v10;
  v11=etr.v11;
  v12=etr.v12;
  v13=etr.v13;
  val=etr.el;
}
void unroll_entry14(const Tensor14_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(28);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.o10;
  idx[11]=etr.o11;
  idx[12]=etr.o12;
  idx[13]=etr.o13;
  idx[14]=etr.v0;
  idx[15]=etr.v1;
  idx[16]=etr.v2;
  idx[17]=etr.v3;
  idx[18]=etr.v4;
  idx[19]=etr.v5;
  idx[20]=etr.v6;
  idx[21]=etr.v7;
  idx[22]=etr.v8;
  idx[23]=etr.v9;
  idx[24]=etr.v10;
  idx[25]=etr.v11;
  idx[26]=etr.v12;
  idx[27]=etr.v13;
  val = etr.el;
}
Tensor14::Tensor14() {
}
Tensor14::Tensor14(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 14) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(o10=o9+1;o10<(orbind_t) list[idet].occ.size();o10++)
      if(!list[idet].occ[o10]) break;
    for(o11=o10+1;o11<(orbind_t) list[idet].occ.size();o11++)
      if(!list[idet].occ[o11]) break;
    for(o12=o11+1;o12<(orbind_t) list[idet].occ.size();o12++)
      if(!list[idet].occ[o12]) break;
    for(o13=o12+1;o13<(orbind_t) list[idet].occ.size();o13++)
      if(!list[idet].occ[o13]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    for(v10=v9+1;v10<(orbind_t) list[idet].virt.size();v10++)
      if(list[idet].virt[v10]) break;
    for(v11=v10+1;v11<(orbind_t) list[idet].virt.size();v11++)
      if(list[idet].virt[v11]) break;
    for(v12=v11+1;v12<(orbind_t) list[idet].virt.size();v12++)
      if(list[idet].virt[v12]) break;
    for(v13=v12+1;v13<(orbind_t) list[idet].virt.size();v13++)
      if(list[idet].virt[v13]) break;
    Tensor14_entry_t etr(make_entry14(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-14 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,o10,o11,o12,o13,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13);
#endif
  }
}
Tensor14::~Tensor14() {
}
void Tensor14::add(const Tensor14_entry_t & val) {
  std::vector<Tensor14_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor14::size() const {
 return list.size();
}
double Tensor14::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t o13, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12, orbind_t v13) const {
  Tensor14_entry_t key(make_entry14(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13));
  std::vector<Tensor14_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor14_entry_t Tensor14::get(size_t idx) const {
  return list[idx];
}
void Tensor14::set(size_t idx, Tensor14_entry_t val) {
  list[idx]=val;
}
void Tensor14::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor14::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor14::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].o10,list[i].o11,list[i].o12,list[i].o13,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].v10,list[i].v11,list[i].v12,list[i].v13,list[i].el);
  }
}
bool operator<(const Tensor15_entry_t & lh, const Tensor15_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.o10 < rh.o10) return true;
  if(lh.o10 > rh.o10) return false;
  if(lh.o11 < rh.o11) return true;
  if(lh.o11 > rh.o11) return false;
  if(lh.o12 < rh.o12) return true;
  if(lh.o12 > rh.o12) return false;
  if(lh.o13 < rh.o13) return true;
  if(lh.o13 > rh.o13) return false;
  if(lh.o14 < rh.o14) return true;
  if(lh.o14 > rh.o14) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  if(lh.v10 < rh.v10) return true;
  if(lh.v10 > rh.v10) return false;
  if(lh.v11 < rh.v11) return true;
  if(lh.v11 > rh.v11) return false;
  if(lh.v12 < rh.v12) return true;
  if(lh.v12 > rh.v12) return false;
  if(lh.v13 < rh.v13) return true;
  if(lh.v13 > rh.v13) return false;
  if(lh.v14 < rh.v14) return true;
  if(lh.v14 > rh.v14) return false;
  return false;
}
bool operator==(const Tensor15_entry_t & lh, const Tensor15_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.o10 != rh.o10) return false;
  if(lh.o11 != rh.o11) return false;
  if(lh.o12 != rh.o12) return false;
  if(lh.o13 != rh.o13) return false;
  if(lh.o14 != rh.o14) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  if(lh.v10 != rh.v10) return false;
  if(lh.v11 != rh.v11) return false;
  if(lh.v12 != rh.v12) return false;
  if(lh.v13 != rh.v13) return false;
  if(lh.v14 != rh.v14) return false;
  return true;
}
Tensor15_entry_t make_entry15(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t o13, orbind_t o14, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12, orbind_t v13, orbind_t v14) {
  Tensor15_entry_t etr;

  std::vector<orbind_t> oidx(15);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;
  oidx[10]=o10;
  oidx[11]=o11;
  oidx[12]=o12;
  oidx[13]=o13;
  oidx[14]=o14;

  std::vector<orbind_t> vidx(15);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;
  vidx[10]=v10;
  vidx[11]=v11;
  vidx[12]=v12;
  vidx[13]=v13;
  vidx[14]=v14;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.o10=soidx[10];
  etr.o11=soidx[11];
  etr.o12=soidx[12];
  etr.o13=soidx[13];
  etr.o14=soidx[14];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];
  etr.v10=svidx[10];
  etr.v11=svidx[11];
  etr.v12=svidx[12];
  etr.v13=svidx[13];
  etr.v14=svidx[14];

  return etr;
}
void unroll_entry15(const Tensor15_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & o10, orbind_t & o11, orbind_t & o12, orbind_t & o13, orbind_t & o14, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, orbind_t & v10, orbind_t & v11, orbind_t & v12, orbind_t & v13, orbind_t & v14, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  o10=etr.o10;
  o11=etr.o11;
  o12=etr.o12;
  o13=etr.o13;
  o14=etr.o14;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  v10=etr.v10;
  v11=etr.v11;
  v12=etr.v12;
  v13=etr.v13;
  v14=etr.v14;
  val=etr.el;
}
void unroll_entry15(const Tensor15_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(30);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.o10;
  idx[11]=etr.o11;
  idx[12]=etr.o12;
  idx[13]=etr.o13;
  idx[14]=etr.o14;
  idx[15]=etr.v0;
  idx[16]=etr.v1;
  idx[17]=etr.v2;
  idx[18]=etr.v3;
  idx[19]=etr.v4;
  idx[20]=etr.v5;
  idx[21]=etr.v6;
  idx[22]=etr.v7;
  idx[23]=etr.v8;
  idx[24]=etr.v9;
  idx[25]=etr.v10;
  idx[26]=etr.v11;
  idx[27]=etr.v12;
  idx[28]=etr.v13;
  idx[29]=etr.v14;
  val = etr.el;
}
Tensor15::Tensor15() {
}
Tensor15::Tensor15(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 15) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(o10=o9+1;o10<(orbind_t) list[idet].occ.size();o10++)
      if(!list[idet].occ[o10]) break;
    for(o11=o10+1;o11<(orbind_t) list[idet].occ.size();o11++)
      if(!list[idet].occ[o11]) break;
    for(o12=o11+1;o12<(orbind_t) list[idet].occ.size();o12++)
      if(!list[idet].occ[o12]) break;
    for(o13=o12+1;o13<(orbind_t) list[idet].occ.size();o13++)
      if(!list[idet].occ[o13]) break;
    for(o14=o13+1;o14<(orbind_t) list[idet].occ.size();o14++)
      if(!list[idet].occ[o14]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    for(v10=v9+1;v10<(orbind_t) list[idet].virt.size();v10++)
      if(list[idet].virt[v10]) break;
    for(v11=v10+1;v11<(orbind_t) list[idet].virt.size();v11++)
      if(list[idet].virt[v11]) break;
    for(v12=v11+1;v12<(orbind_t) list[idet].virt.size();v12++)
      if(list[idet].virt[v12]) break;
    for(v13=v12+1;v13<(orbind_t) list[idet].virt.size();v13++)
      if(list[idet].virt[v13]) break;
    for(v14=v13+1;v14<(orbind_t) list[idet].virt.size();v14++)
      if(list[idet].virt[v14]) break;
    Tensor15_entry_t etr(make_entry15(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-15 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,o10,o11,o12,o13,o14,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14);
#endif
  }
}
Tensor15::~Tensor15() {
}
void Tensor15::add(const Tensor15_entry_t & val) {
  std::vector<Tensor15_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor15::size() const {
 return list.size();
}
double Tensor15::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t o13, orbind_t o14, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12, orbind_t v13, orbind_t v14) const {
  Tensor15_entry_t key(make_entry15(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14));
  std::vector<Tensor15_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor15_entry_t Tensor15::get(size_t idx) const {
  return list[idx];
}
void Tensor15::set(size_t idx, Tensor15_entry_t val) {
  list[idx]=val;
}
void Tensor15::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor15::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor15::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].o10,list[i].o11,list[i].o12,list[i].o13,list[i].o14,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].v10,list[i].v11,list[i].v12,list[i].v13,list[i].v14,list[i].el);
  }
}
bool operator<(const Tensor16_entry_t & lh, const Tensor16_entry_t & rh) {
  if(lh.o0 < rh.o0) return true;
  if(lh.o0 > rh.o0) return false;
  if(lh.o1 < rh.o1) return true;
  if(lh.o1 > rh.o1) return false;
  if(lh.o2 < rh.o2) return true;
  if(lh.o2 > rh.o2) return false;
  if(lh.o3 < rh.o3) return true;
  if(lh.o3 > rh.o3) return false;
  if(lh.o4 < rh.o4) return true;
  if(lh.o4 > rh.o4) return false;
  if(lh.o5 < rh.o5) return true;
  if(lh.o5 > rh.o5) return false;
  if(lh.o6 < rh.o6) return true;
  if(lh.o6 > rh.o6) return false;
  if(lh.o7 < rh.o7) return true;
  if(lh.o7 > rh.o7) return false;
  if(lh.o8 < rh.o8) return true;
  if(lh.o8 > rh.o8) return false;
  if(lh.o9 < rh.o9) return true;
  if(lh.o9 > rh.o9) return false;
  if(lh.o10 < rh.o10) return true;
  if(lh.o10 > rh.o10) return false;
  if(lh.o11 < rh.o11) return true;
  if(lh.o11 > rh.o11) return false;
  if(lh.o12 < rh.o12) return true;
  if(lh.o12 > rh.o12) return false;
  if(lh.o13 < rh.o13) return true;
  if(lh.o13 > rh.o13) return false;
  if(lh.o14 < rh.o14) return true;
  if(lh.o14 > rh.o14) return false;
  if(lh.o15 < rh.o15) return true;
  if(lh.o15 > rh.o15) return false;
  if(lh.v0 < rh.v0) return true;
  if(lh.v0 > rh.v0) return false;
  if(lh.v1 < rh.v1) return true;
  if(lh.v1 > rh.v1) return false;
  if(lh.v2 < rh.v2) return true;
  if(lh.v2 > rh.v2) return false;
  if(lh.v3 < rh.v3) return true;
  if(lh.v3 > rh.v3) return false;
  if(lh.v4 < rh.v4) return true;
  if(lh.v4 > rh.v4) return false;
  if(lh.v5 < rh.v5) return true;
  if(lh.v5 > rh.v5) return false;
  if(lh.v6 < rh.v6) return true;
  if(lh.v6 > rh.v6) return false;
  if(lh.v7 < rh.v7) return true;
  if(lh.v7 > rh.v7) return false;
  if(lh.v8 < rh.v8) return true;
  if(lh.v8 > rh.v8) return false;
  if(lh.v9 < rh.v9) return true;
  if(lh.v9 > rh.v9) return false;
  if(lh.v10 < rh.v10) return true;
  if(lh.v10 > rh.v10) return false;
  if(lh.v11 < rh.v11) return true;
  if(lh.v11 > rh.v11) return false;
  if(lh.v12 < rh.v12) return true;
  if(lh.v12 > rh.v12) return false;
  if(lh.v13 < rh.v13) return true;
  if(lh.v13 > rh.v13) return false;
  if(lh.v14 < rh.v14) return true;
  if(lh.v14 > rh.v14) return false;
  if(lh.v15 < rh.v15) return true;
  if(lh.v15 > rh.v15) return false;
  return false;
}
bool operator==(const Tensor16_entry_t & lh, const Tensor16_entry_t & rh) {
  if(lh.o0 != rh.o0) return false;
  if(lh.o1 != rh.o1) return false;
  if(lh.o2 != rh.o2) return false;
  if(lh.o3 != rh.o3) return false;
  if(lh.o4 != rh.o4) return false;
  if(lh.o5 != rh.o5) return false;
  if(lh.o6 != rh.o6) return false;
  if(lh.o7 != rh.o7) return false;
  if(lh.o8 != rh.o8) return false;
  if(lh.o9 != rh.o9) return false;
  if(lh.o10 != rh.o10) return false;
  if(lh.o11 != rh.o11) return false;
  if(lh.o12 != rh.o12) return false;
  if(lh.o13 != rh.o13) return false;
  if(lh.o14 != rh.o14) return false;
  if(lh.o15 != rh.o15) return false;
  if(lh.v0 != rh.v0) return false;
  if(lh.v1 != rh.v1) return false;
  if(lh.v2 != rh.v2) return false;
  if(lh.v3 != rh.v3) return false;
  if(lh.v4 != rh.v4) return false;
  if(lh.v5 != rh.v5) return false;
  if(lh.v6 != rh.v6) return false;
  if(lh.v7 != rh.v7) return false;
  if(lh.v8 != rh.v8) return false;
  if(lh.v9 != rh.v9) return false;
  if(lh.v10 != rh.v10) return false;
  if(lh.v11 != rh.v11) return false;
  if(lh.v12 != rh.v12) return false;
  if(lh.v13 != rh.v13) return false;
  if(lh.v14 != rh.v14) return false;
  if(lh.v15 != rh.v15) return false;
  return true;
}
Tensor16_entry_t make_entry16(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t o13, orbind_t o14, orbind_t o15, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12, orbind_t v13, orbind_t v14, orbind_t v15) {
  Tensor16_entry_t etr;

  std::vector<orbind_t> oidx(16);
  oidx[0]=o0;
  oidx[1]=o1;
  oidx[2]=o2;
  oidx[3]=o3;
  oidx[4]=o4;
  oidx[5]=o5;
  oidx[6]=o6;
  oidx[7]=o7;
  oidx[8]=o8;
  oidx[9]=o9;
  oidx[10]=o10;
  oidx[11]=o11;
  oidx[12]=o12;
  oidx[13]=o13;
  oidx[14]=o14;
  oidx[15]=o15;

  std::vector<orbind_t> vidx(16);
  vidx[0]=v0;
  vidx[1]=v1;
  vidx[2]=v2;
  vidx[3]=v3;
  vidx[4]=v4;
  vidx[5]=v5;
  vidx[6]=v6;
  vidx[7]=v7;
  vidx[8]=v8;
  vidx[9]=v9;
  vidx[10]=v10;
  vidx[11]=v11;
  vidx[12]=v12;
  vidx[13]=v13;
  vidx[14]=v14;
  vidx[15]=v15;

  int osign, vsign;
  std::vector<orbind_t> soidx(sort(oidx,osign));
  std::vector<orbind_t> svidx(sort(vidx,vsign));

  etr.el=osign*vsign;
  etr.o0=soidx[0];
  etr.o1=soidx[1];
  etr.o2=soidx[2];
  etr.o3=soidx[3];
  etr.o4=soidx[4];
  etr.o5=soidx[5];
  etr.o6=soidx[6];
  etr.o7=soidx[7];
  etr.o8=soidx[8];
  etr.o9=soidx[9];
  etr.o10=soidx[10];
  etr.o11=soidx[11];
  etr.o12=soidx[12];
  etr.o13=soidx[13];
  etr.o14=soidx[14];
  etr.o15=soidx[15];
  etr.v0=svidx[0];
  etr.v1=svidx[1];
  etr.v2=svidx[2];
  etr.v3=svidx[3];
  etr.v4=svidx[4];
  etr.v5=svidx[5];
  etr.v6=svidx[6];
  etr.v7=svidx[7];
  etr.v8=svidx[8];
  etr.v9=svidx[9];
  etr.v10=svidx[10];
  etr.v11=svidx[11];
  etr.v12=svidx[12];
  etr.v13=svidx[13];
  etr.v14=svidx[14];
  etr.v15=svidx[15];

  return etr;
}
void unroll_entry16(const Tensor16_entry_t & etr, orbind_t & o0, orbind_t & o1, orbind_t & o2, orbind_t & o3, orbind_t & o4, orbind_t & o5, orbind_t & o6, orbind_t & o7, orbind_t & o8, orbind_t & o9, orbind_t & o10, orbind_t & o11, orbind_t & o12, orbind_t & o13, orbind_t & o14, orbind_t & o15, orbind_t & v0, orbind_t & v1, orbind_t & v2, orbind_t & v3, orbind_t & v4, orbind_t & v5, orbind_t & v6, orbind_t & v7, orbind_t & v8, orbind_t & v9, orbind_t & v10, orbind_t & v11, orbind_t & v12, orbind_t & v13, orbind_t & v14, orbind_t & v15, double & val) {
  o0=etr.o0;
  o1=etr.o1;
  o2=etr.o2;
  o3=etr.o3;
  o4=etr.o4;
  o5=etr.o5;
  o6=etr.o6;
  o7=etr.o7;
  o8=etr.o8;
  o9=etr.o9;
  o10=etr.o10;
  o11=etr.o11;
  o12=etr.o12;
  o13=etr.o13;
  o14=etr.o14;
  o15=etr.o15;
  v0=etr.v0;
  v1=etr.v1;
  v2=etr.v2;
  v3=etr.v3;
  v4=etr.v4;
  v5=etr.v5;
  v6=etr.v6;
  v7=etr.v7;
  v8=etr.v8;
  v9=etr.v9;
  v10=etr.v10;
  v11=etr.v11;
  v12=etr.v12;
  v13=etr.v13;
  v14=etr.v14;
  v15=etr.v15;
  val=etr.el;
}
void unroll_entry16(const Tensor16_entry_t & etr, std::vector<orbind_t> & idx, double & val) {
  idx.resize(32);
  idx[0]=etr.o0;
  idx[1]=etr.o1;
  idx[2]=etr.o2;
  idx[3]=etr.o3;
  idx[4]=etr.o4;
  idx[5]=etr.o5;
  idx[6]=etr.o6;
  idx[7]=etr.o7;
  idx[8]=etr.o8;
  idx[9]=etr.o9;
  idx[10]=etr.o10;
  idx[11]=etr.o11;
  idx[12]=etr.o12;
  idx[13]=etr.o13;
  idx[14]=etr.o14;
  idx[15]=etr.o15;
  idx[16]=etr.v0;
  idx[17]=etr.v1;
  idx[18]=etr.v2;
  idx[19]=etr.v3;
  idx[20]=etr.v4;
  idx[21]=etr.v5;
  idx[22]=etr.v6;
  idx[23]=etr.v7;
  idx[24]=etr.v8;
  idx[25]=etr.v9;
  idx[26]=etr.v10;
  idx[27]=etr.v11;
  idx[28]=etr.v12;
  idx[29]=etr.v13;
  idx[30]=etr.v14;
  idx[31]=etr.v15;
  val = etr.el;
}
Tensor16::Tensor16() {
}
Tensor16::Tensor16(const std::vector<determinant_t> & list) {
  for(size_t idet=0;idet<list.size();idet++) {
    if(list[idet].rank != 16) continue;
    orbind_t o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15;
    orbind_t v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15;
    for(o0=0;o0<(orbind_t) list[idet].occ.size();o0++)
      if(!list[idet].occ[o0]) break;
    for(o1=o0+1;o1<(orbind_t) list[idet].occ.size();o1++)
      if(!list[idet].occ[o1]) break;
    for(o2=o1+1;o2<(orbind_t) list[idet].occ.size();o2++)
      if(!list[idet].occ[o2]) break;
    for(o3=o2+1;o3<(orbind_t) list[idet].occ.size();o3++)
      if(!list[idet].occ[o3]) break;
    for(o4=o3+1;o4<(orbind_t) list[idet].occ.size();o4++)
      if(!list[idet].occ[o4]) break;
    for(o5=o4+1;o5<(orbind_t) list[idet].occ.size();o5++)
      if(!list[idet].occ[o5]) break;
    for(o6=o5+1;o6<(orbind_t) list[idet].occ.size();o6++)
      if(!list[idet].occ[o6]) break;
    for(o7=o6+1;o7<(orbind_t) list[idet].occ.size();o7++)
      if(!list[idet].occ[o7]) break;
    for(o8=o7+1;o8<(orbind_t) list[idet].occ.size();o8++)
      if(!list[idet].occ[o8]) break;
    for(o9=o8+1;o9<(orbind_t) list[idet].occ.size();o9++)
      if(!list[idet].occ[o9]) break;
    for(o10=o9+1;o10<(orbind_t) list[idet].occ.size();o10++)
      if(!list[idet].occ[o10]) break;
    for(o11=o10+1;o11<(orbind_t) list[idet].occ.size();o11++)
      if(!list[idet].occ[o11]) break;
    for(o12=o11+1;o12<(orbind_t) list[idet].occ.size();o12++)
      if(!list[idet].occ[o12]) break;
    for(o13=o12+1;o13<(orbind_t) list[idet].occ.size();o13++)
      if(!list[idet].occ[o13]) break;
    for(o14=o13+1;o14<(orbind_t) list[idet].occ.size();o14++)
      if(!list[idet].occ[o14]) break;
    for(o15=o14+1;o15<(orbind_t) list[idet].occ.size();o15++)
      if(!list[idet].occ[o15]) break;
    for(v0=0;v0<(orbind_t) list[idet].virt.size();v0++)
      if(list[idet].virt[v0]) break;
    for(v1=v0+1;v1<(orbind_t) list[idet].virt.size();v1++)
      if(list[idet].virt[v1]) break;
    for(v2=v1+1;v2<(orbind_t) list[idet].virt.size();v2++)
      if(list[idet].virt[v2]) break;
    for(v3=v2+1;v3<(orbind_t) list[idet].virt.size();v3++)
      if(list[idet].virt[v3]) break;
    for(v4=v3+1;v4<(orbind_t) list[idet].virt.size();v4++)
      if(list[idet].virt[v4]) break;
    for(v5=v4+1;v5<(orbind_t) list[idet].virt.size();v5++)
      if(list[idet].virt[v5]) break;
    for(v6=v5+1;v6<(orbind_t) list[idet].virt.size();v6++)
      if(list[idet].virt[v6]) break;
    for(v7=v6+1;v7<(orbind_t) list[idet].virt.size();v7++)
      if(list[idet].virt[v7]) break;
    for(v8=v7+1;v8<(orbind_t) list[idet].virt.size();v8++)
      if(list[idet].virt[v8]) break;
    for(v9=v8+1;v9<(orbind_t) list[idet].virt.size();v9++)
      if(list[idet].virt[v9]) break;
    for(v10=v9+1;v10<(orbind_t) list[idet].virt.size();v10++)
      if(list[idet].virt[v10]) break;
    for(v11=v10+1;v11<(orbind_t) list[idet].virt.size();v11++)
      if(list[idet].virt[v11]) break;
    for(v12=v11+1;v12<(orbind_t) list[idet].virt.size();v12++)
      if(list[idet].virt[v12]) break;
    for(v13=v12+1;v13<(orbind_t) list[idet].virt.size();v13++)
      if(list[idet].virt[v13]) break;
    for(v14=v13+1;v14<(orbind_t) list[idet].virt.size();v14++)
      if(list[idet].virt[v14]) break;
    for(v15=v14+1;v15<(orbind_t) list[idet].virt.size();v15++)
      if(list[idet].virt[v15]) break;
    Tensor16_entry_t etr(make_entry16(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15));
    etr.el *= list[idet].coeff;
    add(etr);

#ifdef PRINTOUT
    printf("Rank-16 determinant %6i with coefficient % e with ",(int) idet, list[idet].coeff);
    printf(" %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i -> %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i\n",o0,o1,o2,o3,o4,o5,o6,o7,o8,o9,o10,o11,o12,o13,o14,o15,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15);
#endif
  }
}
Tensor16::~Tensor16() {
}
void Tensor16::add(const Tensor16_entry_t & val) {
  std::vector<Tensor16_entry_t>::iterator low;
  low=std::lower_bound(list.begin(),list.end(),val);
  if(low != list.end() && *low == val)
    low->el += val.el;
  else
    list.insert(low, val);
}
size_t Tensor16::size() const {
 return list.size();
}
double Tensor16::operator()(orbind_t o0, orbind_t o1, orbind_t o2, orbind_t o3, orbind_t o4, orbind_t o5, orbind_t o6, orbind_t o7, orbind_t o8, orbind_t o9, orbind_t o10, orbind_t o11, orbind_t o12, orbind_t o13, orbind_t o14, orbind_t o15, orbind_t v0, orbind_t v1, orbind_t v2, orbind_t v3, orbind_t v4, orbind_t v5, orbind_t v6, orbind_t v7, orbind_t v8, orbind_t v9, orbind_t v10, orbind_t v11, orbind_t v12, orbind_t v13, orbind_t v14, orbind_t v15) const {
  Tensor16_entry_t key(make_entry16(o0, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15));
  std::vector<Tensor16_entry_t>::const_iterator low;
  low=std::lower_bound(list.begin(),list.end(),key);
  if(low != list.end() && *low == key)
    return key.el*low->el;
  else
    return 0.0;
}
Tensor16_entry_t Tensor16::get(size_t idx) const {
  return list[idx];
}
void Tensor16::set(size_t idx, Tensor16_entry_t val) {
  list[idx]=val;
}
void Tensor16::set(size_t idx, double val) {
  list[idx].el=val;
}
double Tensor16::norm() const {
  double n=0.0;
  for(size_t i=0;i<list.size();i++)
    n+=list[i].el*list[i].el;
  return n;
}
void Tensor16::print(double thr) const {
  for(size_t i=0;i<list.size();i++) {
    if(fabs(list[i].el)<thr) continue;
    printf("(%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) -> (%2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i, %2i) % e\n",list[i].o0,list[i].o1,list[i].o2,list[i].o3,list[i].o4,list[i].o5,list[i].o6,list[i].o7,list[i].o8,list[i].o9,list[i].o10,list[i].o11,list[i].o12,list[i].o13,list[i].o14,list[i].o15,list[i].v0,list[i].v1,list[i].v2,list[i].v3,list[i].v4,list[i].v5,list[i].v6,list[i].v7,list[i].v8,list[i].v9,list[i].v10,list[i].v11,list[i].v12,list[i].v13,list[i].v14,list[i].v15,list[i].el);
  }
}
