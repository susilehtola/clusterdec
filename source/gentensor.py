# Written by Susi Lehtola, 2016
# Copyright (c) 2016, Susi Lehtola
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

from __future__ import print_function

h=open('tensor.hh','w')
h.write("/*\n Written by Susi Lehtola, 2016\n Copyright (c) 2016, Susi Lehtola\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n*/\n\n")
h.write("/* This code is autogenerated by gentensor.py. Don't edit it by hand. */\n\n")
h.write("#ifndef TENSOR_HH\n#define TENSOR_HH\n")
h.write("#include <vector>\n")
h.write("#include <cstddef>\n")
h.write("#include \"types.hh\"\n")
h.write("#include \"parser.hh\"\n\n")

c=open('tensor.cc','w')
c.write("/*\n Written by Susi Lehtola, 2016\n Copyright (c) 2016, Susi Lehtola\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n*/\n\n")
c.write("/* This code is autogenerated by gentensor.py. Don't edit it by hand. */\n\n")
c.write("#include \"tensor.hh\"\n")
c.write("#include \"sort.hh\"\n")
c.write("#include <cmath>\n")
c.write("#include <algorithm>\n")
c.write("#include <stdexcept>\n\n")

for r in range(1,17):
    h.write("typedef struct {\n")

    # Occupied indices
    h.write("  orbind_t ")
    for i in range(r):
        if(i>0):
            h.write(", ")
        h.write("o{}".format(i))
    h.write(";\n")

    # Virtual indices
    h.write("  orbind_t ")
    for i in range(r):
        if(i>0):
            h.write(", ")
        h.write("v{}".format(i))
    h.write(";\n")

    # Element
    h.write("  double el;\n")
    h.write("}} Tensor{}_entry_t;\n".format(r))

    # Comparison operator
    h.write("bool operator<(const Tensor{0}_entry_t & lh, const Tensor{0}_entry_t & rh);\n".format(r))
    c.write("bool operator<(const Tensor{0}_entry_t & lh, const Tensor{0}_entry_t & rh) {{\n".format(r))
    for i in range(r):
        c.write("  if(lh.o{0} < rh.o{0}) return true;\n".format(i))
        c.write("  if(lh.o{0} > rh.o{0}) return false;\n".format(i))
    for i in range(r):
        c.write("  if(lh.v{0} < rh.v{0}) return true;\n".format(i))
        c.write("  if(lh.v{0} > rh.v{0}) return false;\n".format(i))
    c.write("  return false;\n")
    c.write("}\n")

    h.write("bool operator==(const Tensor{0}_entry_t & lh, const Tensor{0}_entry_t & rh);\n".format(r))
    c.write("bool operator==(const Tensor{0}_entry_t & lh, const Tensor{0}_entry_t & rh) {{\n".format(r))
    for i in range(r):
        c.write("  if(lh.o{0} != rh.o{0}) return false;\n".format(i))
    for i in range(r):
        c.write("  if(lh.v{0} != rh.v{0}) return false;\n".format(i))
    c.write("  return true;\n")
    c.write("}\n")

    # Convert indices into suitable entry
    h.write("Tensor{0}_entry_t make_entry{0}(".format(r))
    for i in range(r):
        if(i>0):
            h.write(", ")
        h.write("orbind_t o{}".format(i))
    for i in range(r):
        h.write(", orbind_t v{}".format(i))
    h.write(");\n")

    c.write("Tensor{0}_entry_t make_entry{0}(".format(r))
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("orbind_t o{}".format(i))
    for i in range(r):
        c.write(", orbind_t v{}".format(i))
    c.write(") {\n")

    c.write("  Tensor{}_entry_t etr;\n\n".format(r))

    # First, we need to sort the indices into order.
    if(r>1):
        c.write("  std::vector<orbind_t> oidx({});\n".format(r))
        for i in range(r):
            c.write("  oidx[{0}]=o{0};\n".format(i))
        c.write("\n  std::vector<orbind_t> vidx({});\n".format(r))
        for i in range(r):
            c.write("  vidx[{0}]=v{0};\n".format(i))

        # Get the sorted indices and permutation sign
        c.write("\n  int osign, vsign;\n")
        c.write("  std::vector<orbind_t> soidx(sort(oidx,osign));\n".format(r))
        c.write("  std::vector<orbind_t> svidx(sort(vidx,vsign));\n\n".format(r))

        c.write("  etr.el=osign*vsign;\n")
        for i in range(r):
            c.write("  etr.o{0}=soidx[{0}];\n".format(i))
        for i in range(r):
            c.write("  etr.v{0}=svidx[{0}];\n".format(i))

    else:
        c.write("  etr.el=1.0;\n")
        for i in range(r):
            c.write("  etr.o{0}=o{0};\n".format(i))
        for i in range(r):
            c.write("  etr.v{0}=v{0};\n".format(i))

    c.write("\n  return etr;\n")
    c.write("}\n")

    # Extract entry
    h.write("void unroll_entry{0}(const Tensor{0}_entry_t & etr".format(r))
    for i in range(r):
        h.write(", orbind_t & o{}".format(i))
    for i in range(r):
        h.write(", orbind_t & v{}".format(i))
    h.write(", double & val);\n")

    c.write("void unroll_entry{0}(const Tensor{0}_entry_t & etr".format(r))
    for i in range(r):
        c.write(", orbind_t & o{}".format(i))
    for i in range(r):
        c.write(", orbind_t & v{}".format(i))
    c.write(", double & val) {\n")
    for i in range(r):
        c.write("  o{0}=etr.o{0};\n".format(i))
    for i in range(r):
        c.write("  v{0}=etr.v{0};\n".format(i))
    c.write("  val=etr.el;\n".format(i))
    c.write("}\n")

    h.write("void unroll_entry{0}(const Tensor{0}_entry_t & etr, std::vector<orbind_t> & idx, double & val);\n".format(r))
    c.write("void unroll_entry{0}(const Tensor{0}_entry_t & etr, std::vector<orbind_t> & idx, double & val) {{\n".format(r))
    c.write("  idx.resize({});\n".format(2*r));
    for i in range(r):
        c.write("  idx[{0}]=etr.o{0};\n".format(i))
    for i in range(r):
        c.write("  idx[{0}]=etr.v{1};\n".format(i+r,i))
    c.write("  val = etr.el;\n");
    c.write("}\n")

    # Container
    h.write("class Tensor{} {{\n".format(r))
    h.write("  std::vector<Tensor{}_entry_t> list;\n".format(r))
    h.write("public:\n")
    h.write("  Tensor{}();\n".format(r))
    h.write("  Tensor{}(const std::vector<determinant_t> & list);\n".format(r))
    h.write("  ~Tensor{}();\n".format(r))
    h.write("  void add(const Tensor{0}_entry_t & key);\n".format(r))
    h.write("  size_t size() const;\n")
    h.write("  double operator()(")
    for i in range(r):
        if(i>0):
            h.write(", ")
        h.write("orbind_t o{}".format(i))
    for i in range(r):
        h.write(", orbind_t v{}".format(i))
    h.write(") const;\n")
    h.write("  Tensor{}_entry_t get(size_t idx) const;\n".format(r))
    h.write("  void set(size_t idx, Tensor{}_entry_t val);\n".format(r))
    h.write("  void set(size_t idx, double val);\n")
    h.write("  double norm() const;\n")
    h.write("  void print(double thr=1e-10) const;\n")
    h.write("};\n")

    c.write("Tensor{0}::Tensor{0}() {{\n".format(r))
    c.write("}\n")

    c.write("Tensor{0}::Tensor{0}(const std::vector<determinant_t> & list) {{\n".format(r))

    # Loop over determinants
    c.write("  for(size_t idet=0;idet<list.size();idet++) {\n")
    c.write("    if(list[idet].rank != {}) continue;\n".format(r))

    # Occupied indices
    c.write("    orbind_t ")
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("o{}".format(i))
    c.write(";\n")

    # Virtual indices
    c.write("    orbind_t ")
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("v{}".format(i))
    c.write(";\n")

    # Form the list of holes
    for i in range(r):
        if(i==0):
            c.write("    for(o{0}=0;o{0}<(orbind_t) list[idet].occ.size();o{0}++)\n".format(i))
        else:
            c.write("    for(o{0}=o{1}+1;o{0}<(orbind_t) list[idet].occ.size();o{0}++)\n".format(i,i-1))
        c.write("      if(!list[idet].occ[o{}]) break;\n".format(i))
    # Form the list of particles
    for i in range(r):
        if(i==0):
            c.write("    for(v{0}=0;v{0}<(orbind_t) list[idet].virt.size();v{0}++)\n".format(i))
        else:
            c.write("    for(v{0}=v{1}+1;v{0}<(orbind_t) list[idet].virt.size();v{0}++)\n".format(i,i-1))
        c.write("      if(list[idet].virt[v{}]) break;\n".format(i))
    # Generate the entry
    c.write("    Tensor{0}_entry_t etr(make_entry{0}(".format(r))
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("o{}".format(i))
    for i in range(r):
        c.write(", v{}".format(i))
    c.write("));\n")

    # and plug in the coefficient
    c.write("    etr.el *= list[idet].coeff;\n")

    # Add the element to the list
    c.write("    add(etr);\n")

    # Debug printout
    c.write("\n#ifdef PRINTOUT\n")
    c.write("    printf(\"Rank-{} determinant %6i with coefficient % e with \",(int) idet, list[idet].coeff);\n".format(r))
    c.write("    printf(\"")
    for i in range(r):
        c.write(" %i")
    c.write(" ->")
    for i in range(r):
        c.write(" %i")
    c.write("\\n\"")
    for i in range(r):
        c.write(",o{}".format(i))
    for i in range(r):
        c.write(",v{}".format(i))
    c.write(");\n")
    c.write("#endif\n")

    c.write("  }\n")
    #c.write("  printf(\"Rank-{} excitations parsed.\\n\");\n".format(r))
    #c.write("  fflush(stdout);\n")
    c.write("}\n")


    c.write("Tensor{0}::~Tensor{0}() {{\n".format(r))
    c.write("}\n")

    c.write("void Tensor{0}::add(const Tensor{0}_entry_t & val) {{\n".format(r))
    c.write("  std::vector<Tensor{}_entry_t>::iterator low;\n".format(r))
    c.write("  low=std::lower_bound(list.begin(),list.end(),val);\n")
#    c.write("  if(low == list.end())\n")
#    c.write("    list.push_back(val);\n")
    c.write("  if(low != list.end() && *low == val)\n")
    c.write("    low->el += val.el;\n")
    c.write("  else\n")
    c.write("    list.insert(low, val);\n")
    c.write("}\n")

    c.write("size_t Tensor{}::size() const {{\n".format(r))
    c.write(" return list.size();\n")
    c.write("}\n")

    c.write("double Tensor{}::operator()(".format(r))
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("orbind_t o{}".format(i))
    for i in range(r):
        c.write(", orbind_t v{}".format(i))
    c.write(") const {\n")
    c.write("  Tensor{0}_entry_t key(make_entry{0}(".format(r))
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("o{}".format(i))
    for i in range(r):
        c.write(", v{}".format(i))
    c.write("));\n")

    c.write("  std::vector<Tensor{}_entry_t>::const_iterator low;\n".format(r))
    c.write("  low=std::lower_bound(list.begin(),list.end(),key);\n")
    c.write("  if(low != list.end() && *low == key)\n")
    c.write("    return key.el*low->el;\n")
    c.write("  else\n")
    c.write("    return 0.0;\n")
    c.write("}\n")

    c.write("Tensor{0}_entry_t Tensor{0}::get(size_t idx) const {{\n".format(r))
    c.write("  return list[idx];\n")
    c.write("}\n")

    c.write("void Tensor{0}::set(size_t idx, Tensor{0}_entry_t val) {{\n".format(r))
    c.write("  list[idx]=val;\n")
    c.write("}\n")

    c.write("void Tensor{0}::set(size_t idx, double val) {{\n".format(r))
    c.write("  list[idx].el=val;\n")
    c.write("}\n")

    c.write("double Tensor{0}::norm() const {{\n".format(r))
    c.write("  double n=0.0;\n")
    c.write("  for(size_t i=0;i<list.size();i++)\n")
    c.write("    n+=list[i].el*list[i].el;\n")
    c.write("  return n;\n")
    c.write("}\n")

    c.write("void Tensor{0}::print(double thr) const {{\n".format(r))
    c.write("  for(size_t i=0;i<list.size();i++) {\n")
    c.write("    if(fabs(list[i].el)<thr) continue;\n")
    c.write("    printf(\"(")
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("%2i")
    c.write(") -> (");
    for i in range(r):
        if(i>0):
            c.write(", ")
        c.write("%2i")
    c.write(") % e\\n\"");
    for i in range(r):
        c.write(",list[i].o{}".format(i))
    for i in range(r):
        c.write(",list[i].v{}".format(i))
    c.write(",list[i].el);\n")
    c.write("  }\n")
    c.write("}\n")


h.write("#endif")
